/******************************************************************************
** $Id$
**
** Copyright (C) 2006-2009 ascolab GmbH. All Rights Reserved.
** Web: http://www.ascolab.com
** 
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
** 
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
** 
** Project: OpcUa Wireshark Plugin
**
** Description: Service table and service dispatcher.
**
** This file was autogenerated on 31.03.2009.
** DON'T MODIFY THIS FILE!
** XXX - well, except that you may have to.  See the README.
**
******************************************************************************/

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <glib.h>
#include <epan/packet.h>
#include "opcua_simpletypes.h"
#include "opcua_complextypeparser.h"
#include "opcua_extensionobjectids.h"
#include "opcua_hfindeces.h"

ExtensionObjectParserEntry g_arExtensionObjectParserTable[] = {
    { OpcUaId_DataChangeNotification_Encoding_DefaultBinary, parseDataChangeNotification, "DataChangeNotification" },
    { OpcUaId_EventNotificationList_Encoding_DefaultBinary, parseEventNotificationList, "EventNotificationList" },
};
const int g_NumTypes = sizeof(g_arExtensionObjectParserTable) / sizeof(ExtensionObjectParserEntry);

/** Dispatch all extension objects to a special parser function. */
void dispatchExtensionObjectType(proto_tree *tree, tvbuff_t *tvb, gint *pOffset, int TypeId)
{
    gint    iOffset = *pOffset;
    int     index = 0;
    int     bFound = 0;
    gint32  iLen = 0;

    /* get the length of the body */
    iLen = tvb_get_letohl(tvb, iOffset);
    iOffset += 4;

    while (index < g_NumTypes)
    {
        if (g_arExtensionObjectParserTable[index].iRequestId == TypeId)
        {
            bFound = 1;
            (*g_arExtensionObjectParserTable[index].pParser)(tree, tvb, &iOffset, g_arExtensionObjectParserTable[index].typeName);
            break;
        }
        index++;
    }

    /* display contained object as ByteString if unknown type */
    if (bFound == 0)
    {
        if (iLen == -1)
        {
            proto_tree_add_text(tree, tvb, iOffset, 0, "[OpcUa Null ByteString]");
        }
        else if (iLen >= 0)
        {
            proto_tree_add_item(tree, hf_opcua_ByteString, tvb, iOffset, iLen, TRUE);
            iOffset += iLen; /* eat the whole bytestring */
        }
        else
        {
            char *szValue = ep_strdup_printf("[Invalid ByteString] Invalid length: %d", iLen);
            proto_tree_add_text(tree, tvb, iOffset, 0, "%s", szValue);
        }
    }

    *pOffset = iOffset;
}

